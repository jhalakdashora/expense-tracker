{"ast":null,"code":"import { SPLIT_TYPES } from '@/constants';\nimport { toFixed } from './formatters';\n\n/**\n * Generates a unique ID\n * @returns {string} Unique ID\n */\nexport const generateId = () => {\n  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n};\n\n/**\n * Calculate split amounts based on split type\n * @param {number} totalAmount - Total expense amount\n * @param {Array} selectedMembers - Array of member IDs\n * @param {string} splitType - Type of split (equal, exact, percentage)\n * @param {Object} customSplits - Custom split amounts/percentages\n * @returns {Array} Array of split objects\n */\nexport const calculateSplits = (totalAmount, selectedMembers, splitType = SPLIT_TYPES.EQUAL, customSplits = {}) => {\n  const splits = [];\n  if (splitType === SPLIT_TYPES.EQUAL) {\n    const amountPerPerson = totalAmount / selectedMembers.length;\n    selectedMembers.forEach((userId, index) => {\n      // Handle rounding by giving the remainder to the last person\n      let amount;\n      if (index === selectedMembers.length - 1) {\n        const previousTotal = amountPerPerson * index;\n        amount = toFixed(totalAmount - previousTotal);\n      } else {\n        amount = toFixed(amountPerPerson);\n      }\n      splits.push({\n        userId,\n        amount\n      });\n    });\n  } else if (splitType === SPLIT_TYPES.EXACT) {\n    selectedMembers.forEach(userId => {\n      const amount = toFixed(customSplits[userId] || 0);\n      splits.push({\n        userId,\n        amount\n      });\n    });\n  } else if (splitType === SPLIT_TYPES.PERCENTAGE) {\n    selectedMembers.forEach((userId, index) => {\n      const percentage = customSplits[userId] || 0;\n      let amount;\n      if (index === selectedMembers.length - 1) {\n        // Give remainder to last person to handle rounding\n        const previousTotal = splits.reduce((sum, s) => sum + s.amount, 0);\n        amount = toFixed(totalAmount - previousTotal);\n      } else {\n        amount = toFixed(totalAmount * percentage / 100);\n      }\n      splits.push({\n        userId,\n        amount\n      });\n    });\n  }\n  return splits;\n};\n\n/**\n * Get category by ID\n * @param {Array} categories - Array of category objects\n * @param {string} categoryId - Category ID\n * @returns {Object|null} Category object or null\n */\nexport const getCategoryById = (categories, categoryId) => {\n  return categories.find(cat => cat.id === categoryId) || null;\n};\n\n/**\n * Filter expenses by group\n * @param {Array} expenses - Array of expense objects\n * @param {string} groupId - Group ID\n * @returns {Array} Filtered expenses\n */\nexport const filterExpensesByGroup = (expenses, groupId) => {\n  if (!groupId) return expenses;\n  return expenses.filter(expense => expense.groupId === groupId);\n};\n\n/**\n * Filter expenses by date range\n * @param {Array} expenses - Array of expense objects\n * @param {Date} startDate - Start date\n * @param {Date} endDate - End date\n * @returns {Array} Filtered expenses\n */\nexport const filterExpensesByDateRange = (expenses, startDate, endDate) => {\n  return expenses.filter(expense => {\n    const expenseDate = new Date(expense.date);\n    return expenseDate >= startDate && expenseDate <= endDate;\n  });\n};\n\n/**\n * Sort expenses by date (newest first)\n * @param {Array} expenses - Array of expense objects\n * @returns {Array} Sorted expenses\n */\nexport const sortExpensesByDate = expenses => {\n  return [...expenses].sort((a, b) => new Date(b.date) - new Date(a.date));\n};\n\n/**\n * Group expenses by date\n * @param {Array} expenses - Array of expense objects\n * @returns {Object} Expenses grouped by date\n */\nexport const groupExpensesByDate = expenses => {\n  const grouped = {};\n  expenses.forEach(expense => {\n    const date = new Date(expense.date).toDateString();\n    if (!grouped[date]) {\n      grouped[date] = [];\n    }\n    grouped[date].push(expense);\n  });\n  return grouped;\n};\n\n/**\n * Calculate total expenses\n * @param {Array} expenses - Array of expense objects\n * @returns {number} Total amount\n */\nexport const calculateTotalExpenses = expenses => {\n  return toFixed(expenses.reduce((sum, expense) => sum + expense.amount, 0));\n};\n\n/**\n * Deep clone an object\n * @param {*} obj - Object to clone\n * @returns {*} Cloned object\n */\nexport const deepClone = obj => {\n  return JSON.parse(JSON.stringify(obj));\n};\n\n/**\n * Debounce function\n * @param {Function} func - Function to debounce\n * @param {number} wait - Wait time in ms\n * @returns {Function} Debounced function\n */\nexport const debounce = (func, wait = 300) => {\n  let timeout;\n  return function executedFunction(...args) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n};","map":{"version":3,"names":["SPLIT_TYPES","toFixed","generateId","Date","now","Math","random","toString","substr","calculateSplits","totalAmount","selectedMembers","splitType","EQUAL","customSplits","splits","amountPerPerson","length","forEach","userId","index","amount","previousTotal","push","EXACT","PERCENTAGE","percentage","reduce","sum","s","getCategoryById","categories","categoryId","find","cat","id","filterExpensesByGroup","expenses","groupId","filter","expense","filterExpensesByDateRange","startDate","endDate","expenseDate","date","sortExpensesByDate","sort","a","b","groupExpensesByDate","grouped","toDateString","calculateTotalExpenses","deepClone","obj","JSON","parse","stringify","debounce","func","wait","timeout","executedFunction","args","later","clearTimeout","setTimeout"],"sources":["/Users/jhalakdashora/Desktop/Study/Expense Tracker react/src/utils/helpers.js"],"sourcesContent":["import { SPLIT_TYPES } from '@/constants';\nimport { toFixed } from './formatters';\n\n/**\n * Generates a unique ID\n * @returns {string} Unique ID\n */\nexport const generateId = () => {\n  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n};\n\n/**\n * Calculate split amounts based on split type\n * @param {number} totalAmount - Total expense amount\n * @param {Array} selectedMembers - Array of member IDs\n * @param {string} splitType - Type of split (equal, exact, percentage)\n * @param {Object} customSplits - Custom split amounts/percentages\n * @returns {Array} Array of split objects\n */\nexport const calculateSplits = (\n  totalAmount,\n  selectedMembers,\n  splitType = SPLIT_TYPES.EQUAL,\n  customSplits = {}\n) => {\n  const splits = [];\n\n  if (splitType === SPLIT_TYPES.EQUAL) {\n    const amountPerPerson = totalAmount / selectedMembers.length;\n    \n    selectedMembers.forEach((userId, index) => {\n      // Handle rounding by giving the remainder to the last person\n      let amount;\n      if (index === selectedMembers.length - 1) {\n        const previousTotal = amountPerPerson * index;\n        amount = toFixed(totalAmount - previousTotal);\n      } else {\n        amount = toFixed(amountPerPerson);\n      }\n\n      splits.push({ userId, amount });\n    });\n  } else if (splitType === SPLIT_TYPES.EXACT) {\n    selectedMembers.forEach((userId) => {\n      const amount = toFixed(customSplits[userId] || 0);\n      splits.push({ userId, amount });\n    });\n  } else if (splitType === SPLIT_TYPES.PERCENTAGE) {\n    selectedMembers.forEach((userId, index) => {\n      const percentage = customSplits[userId] || 0;\n      let amount;\n      \n      if (index === selectedMembers.length - 1) {\n        // Give remainder to last person to handle rounding\n        const previousTotal = splits.reduce((sum, s) => sum + s.amount, 0);\n        amount = toFixed(totalAmount - previousTotal);\n      } else {\n        amount = toFixed((totalAmount * percentage) / 100);\n      }\n      \n      splits.push({ userId, amount });\n    });\n  }\n\n  return splits;\n};\n\n/**\n * Get category by ID\n * @param {Array} categories - Array of category objects\n * @param {string} categoryId - Category ID\n * @returns {Object|null} Category object or null\n */\nexport const getCategoryById = (categories, categoryId) => {\n  return categories.find((cat) => cat.id === categoryId) || null;\n};\n\n/**\n * Filter expenses by group\n * @param {Array} expenses - Array of expense objects\n * @param {string} groupId - Group ID\n * @returns {Array} Filtered expenses\n */\nexport const filterExpensesByGroup = (expenses, groupId) => {\n  if (!groupId) return expenses;\n  return expenses.filter((expense) => expense.groupId === groupId);\n};\n\n/**\n * Filter expenses by date range\n * @param {Array} expenses - Array of expense objects\n * @param {Date} startDate - Start date\n * @param {Date} endDate - End date\n * @returns {Array} Filtered expenses\n */\nexport const filterExpensesByDateRange = (expenses, startDate, endDate) => {\n  return expenses.filter((expense) => {\n    const expenseDate = new Date(expense.date);\n    return expenseDate >= startDate && expenseDate <= endDate;\n  });\n};\n\n/**\n * Sort expenses by date (newest first)\n * @param {Array} expenses - Array of expense objects\n * @returns {Array} Sorted expenses\n */\nexport const sortExpensesByDate = (expenses) => {\n  return [...expenses].sort((a, b) => new Date(b.date) - new Date(a.date));\n};\n\n/**\n * Group expenses by date\n * @param {Array} expenses - Array of expense objects\n * @returns {Object} Expenses grouped by date\n */\nexport const groupExpensesByDate = (expenses) => {\n  const grouped = {};\n  \n  expenses.forEach((expense) => {\n    const date = new Date(expense.date).toDateString();\n    if (!grouped[date]) {\n      grouped[date] = [];\n    }\n    grouped[date].push(expense);\n  });\n\n  return grouped;\n};\n\n/**\n * Calculate total expenses\n * @param {Array} expenses - Array of expense objects\n * @returns {number} Total amount\n */\nexport const calculateTotalExpenses = (expenses) => {\n  return toFixed(expenses.reduce((sum, expense) => sum + expense.amount, 0));\n};\n\n/**\n * Deep clone an object\n * @param {*} obj - Object to clone\n * @returns {*} Cloned object\n */\nexport const deepClone = (obj) => {\n  return JSON.parse(JSON.stringify(obj));\n};\n\n/**\n * Debounce function\n * @param {Function} func - Function to debounce\n * @param {number} wait - Wait time in ms\n * @returns {Function} Debounced function\n */\nexport const debounce = (func, wait = 300) => {\n  let timeout;\n  return function executedFunction(...args) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}