{"ast":null,"code":"import { toFixed } from './formatters';\n\n/**\n * Calculate net balances for all users\n * @param {Array} expenses - Array of expense objects\n * @param {string} currentUserId - Current user's ID\n * @returns {Object} Net balances for each user\n */\nexport const calculateNetBalances = (expenses, currentUserId) => {\n  const balances = {};\n  expenses.forEach(expense => {\n    const {\n      paidBy,\n      splits\n    } = expense;\n\n    // Initialize paidBy user balance if not exists\n    if (!balances[paidBy]) {\n      balances[paidBy] = 0;\n    }\n\n    // Process each split\n    splits.forEach(split => {\n      const {\n        userId,\n        amount\n      } = split;\n\n      // Initialize user balance if not exists\n      if (!balances[userId]) {\n        balances[userId] = 0;\n      }\n\n      // If this user paid for someone else, they are owed\n      if (paidBy !== userId) {\n        balances[paidBy] += amount;\n        balances[userId] -= amount;\n      }\n    });\n  });\n  return balances;\n};\n\n/**\n * Simplify debts to minimize number of transactions\n * Uses greedy algorithm to match largest creditor with largest debtor\n * @param {Object} balances - Net balances for each user\n * @param {Object} users - User objects map\n * @returns {Array} Simplified debt transactions\n */\nexport const simplifyDebts = (balances, users) => {\n  // Create arrays of creditors (positive balance) and debtors (negative balance)\n  const creditors = [];\n  const debtors = [];\n  Object.entries(balances).forEach(([userId, balance]) => {\n    const roundedBalance = toFixed(balance);\n    if (roundedBalance > 0) {\n      creditors.push({\n        userId,\n        amount: roundedBalance\n      });\n    } else if (roundedBalance < 0) {\n      debtors.push({\n        userId,\n        amount: Math.abs(roundedBalance)\n      });\n    }\n  });\n\n  // Sort in descending order\n  creditors.sort((a, b) => b.amount - a.amount);\n  debtors.sort((a, b) => b.amount - a.amount);\n  const transactions = [];\n  let i = 0;\n  let j = 0;\n\n  // Match creditors with debtors\n  while (i < creditors.length && j < debtors.length) {\n    const creditor = creditors[i];\n    const debtor = debtors[j];\n    const amount = Math.min(creditor.amount, debtor.amount);\n    if (amount > 0.01) {\n      var _users$debtor$userId, _users$creditor$userI;\n      // Only create transaction if amount is significant\n      transactions.push({\n        from: debtor.userId,\n        to: creditor.userId,\n        amount: toFixed(amount),\n        fromName: ((_users$debtor$userId = users[debtor.userId]) === null || _users$debtor$userId === void 0 ? void 0 : _users$debtor$userId.name) || 'Unknown',\n        toName: ((_users$creditor$userI = users[creditor.userId]) === null || _users$creditor$userI === void 0 ? void 0 : _users$creditor$userI.name) || 'Unknown'\n      });\n    }\n    creditor.amount = toFixed(creditor.amount - amount);\n    debtor.amount = toFixed(debtor.amount - amount);\n    if (creditor.amount === 0) i++;\n    if (debtor.amount === 0) j++;\n  }\n  return transactions;\n};\n\n/**\n * Calculate balance between current user and all others\n * @param {Object} balances - Net balances\n * @param {string} currentUserId - Current user's ID\n * @param {Object} users - User objects map\n * @returns {Array} Array of balance objects\n */\nexport const getUserBalances = (balances, currentUserId, users) => {\n  const userBalances = [];\n  Object.entries(balances).forEach(([userId, balance]) => {\n    var _users$userId;\n    if (userId === currentUserId || Math.abs(balance) < 0.01) return;\n    const roundedBalance = toFixed(balance);\n    userBalances.push({\n      userId,\n      userName: ((_users$userId = users[userId]) === null || _users$userId === void 0 ? void 0 : _users$userId.name) || 'Unknown',\n      amount: Math.abs(roundedBalance),\n      type: roundedBalance > 0 ? 'owes_you' : 'you_owe'\n    });\n  });\n\n  // Sort by amount descending\n  return userBalances.sort((a, b) => b.amount - a.amount);\n};\n\n/**\n * Calculate total amount user owes\n * @param {Object} balances - Net balances\n * @param {string} userId - User ID\n * @returns {number} Total amount owed by user\n */\nexport const getTotalOwed = (balances, userId) => {\n  const balance = balances[userId] || 0;\n  return balance < 0 ? toFixed(Math.abs(balance)) : 0;\n};\n\n/**\n * Calculate total amount owed to user\n * @param {Object} balances - Net balances\n * @param {string} userId - User ID\n * @returns {number} Total amount owed to user\n */\nexport const getTotalOwing = (balances, userId) => {\n  const balance = balances[userId] || 0;\n  return balance > 0 ? toFixed(balance) : 0;\n};\n\n/**\n * Get balance summary for user\n * @param {Object} balances - Net balances\n * @param {string} userId - User ID\n * @returns {Object} Balance summary\n */\nexport const getBalanceSummary = (balances, userId) => {\n  const balance = balances[userId] || 0;\n  const roundedBalance = toFixed(balance);\n  return {\n    totalOwed: getTotalOwed(balances, userId),\n    totalOwing: getTotalOwing(balances, userId),\n    netBalance: roundedBalance,\n    isSettled: Math.abs(roundedBalance) < 0.01\n  };\n};","map":{"version":3,"names":["toFixed","calculateNetBalances","expenses","currentUserId","balances","forEach","expense","paidBy","splits","split","userId","amount","simplifyDebts","users","creditors","debtors","Object","entries","balance","roundedBalance","push","Math","abs","sort","a","b","transactions","i","j","length","creditor","debtor","min","_users$debtor$userId","_users$creditor$userI","from","to","fromName","name","toName","getUserBalances","userBalances","_users$userId","userName","type","getTotalOwed","getTotalOwing","getBalanceSummary","totalOwed","totalOwing","netBalance","isSettled"],"sources":["/Users/jhalakdashora/Desktop/Study/Expense Tracker react/src/utils/debtSimplification.js"],"sourcesContent":["import { toFixed } from './formatters';\n\n/**\n * Calculate net balances for all users\n * @param {Array} expenses - Array of expense objects\n * @param {string} currentUserId - Current user's ID\n * @returns {Object} Net balances for each user\n */\nexport const calculateNetBalances = (expenses, currentUserId) => {\n  const balances = {};\n\n  expenses.forEach((expense) => {\n    const { paidBy, splits } = expense;\n\n    // Initialize paidBy user balance if not exists\n    if (!balances[paidBy]) {\n      balances[paidBy] = 0;\n    }\n\n    // Process each split\n    splits.forEach((split) => {\n      const { userId, amount } = split;\n\n      // Initialize user balance if not exists\n      if (!balances[userId]) {\n        balances[userId] = 0;\n      }\n\n      // If this user paid for someone else, they are owed\n      if (paidBy !== userId) {\n        balances[paidBy] += amount;\n        balances[userId] -= amount;\n      }\n    });\n  });\n\n  return balances;\n};\n\n/**\n * Simplify debts to minimize number of transactions\n * Uses greedy algorithm to match largest creditor with largest debtor\n * @param {Object} balances - Net balances for each user\n * @param {Object} users - User objects map\n * @returns {Array} Simplified debt transactions\n */\nexport const simplifyDebts = (balances, users) => {\n  // Create arrays of creditors (positive balance) and debtors (negative balance)\n  const creditors = [];\n  const debtors = [];\n\n  Object.entries(balances).forEach(([userId, balance]) => {\n    const roundedBalance = toFixed(balance);\n    \n    if (roundedBalance > 0) {\n      creditors.push({ userId, amount: roundedBalance });\n    } else if (roundedBalance < 0) {\n      debtors.push({ userId, amount: Math.abs(roundedBalance) });\n    }\n  });\n\n  // Sort in descending order\n  creditors.sort((a, b) => b.amount - a.amount);\n  debtors.sort((a, b) => b.amount - a.amount);\n\n  const transactions = [];\n  let i = 0;\n  let j = 0;\n\n  // Match creditors with debtors\n  while (i < creditors.length && j < debtors.length) {\n    const creditor = creditors[i];\n    const debtor = debtors[j];\n\n    const amount = Math.min(creditor.amount, debtor.amount);\n\n    if (amount > 0.01) { // Only create transaction if amount is significant\n      transactions.push({\n        from: debtor.userId,\n        to: creditor.userId,\n        amount: toFixed(amount),\n        fromName: users[debtor.userId]?.name || 'Unknown',\n        toName: users[creditor.userId]?.name || 'Unknown',\n      });\n    }\n\n    creditor.amount = toFixed(creditor.amount - amount);\n    debtor.amount = toFixed(debtor.amount - amount);\n\n    if (creditor.amount === 0) i++;\n    if (debtor.amount === 0) j++;\n  }\n\n  return transactions;\n};\n\n/**\n * Calculate balance between current user and all others\n * @param {Object} balances - Net balances\n * @param {string} currentUserId - Current user's ID\n * @param {Object} users - User objects map\n * @returns {Array} Array of balance objects\n */\nexport const getUserBalances = (balances, currentUserId, users) => {\n  const userBalances = [];\n\n  Object.entries(balances).forEach(([userId, balance]) => {\n    if (userId === currentUserId || Math.abs(balance) < 0.01) return;\n\n    const roundedBalance = toFixed(balance);\n    \n    userBalances.push({\n      userId,\n      userName: users[userId]?.name || 'Unknown',\n      amount: Math.abs(roundedBalance),\n      type: roundedBalance > 0 ? 'owes_you' : 'you_owe',\n    });\n  });\n\n  // Sort by amount descending\n  return userBalances.sort((a, b) => b.amount - a.amount);\n};\n\n/**\n * Calculate total amount user owes\n * @param {Object} balances - Net balances\n * @param {string} userId - User ID\n * @returns {number} Total amount owed by user\n */\nexport const getTotalOwed = (balances, userId) => {\n  const balance = balances[userId] || 0;\n  return balance < 0 ? toFixed(Math.abs(balance)) : 0;\n};\n\n/**\n * Calculate total amount owed to user\n * @param {Object} balances - Net balances\n * @param {string} userId - User ID\n * @returns {number} Total amount owed to user\n */\nexport const getTotalOwing = (balances, userId) => {\n  const balance = balances[userId] || 0;\n  return balance > 0 ? toFixed(balance) : 0;\n};\n\n/**\n * Get balance summary for user\n * @param {Object} balances - Net balances\n * @param {string} userId - User ID\n * @returns {Object} Balance summary\n */\nexport const getBalanceSummary = (balances, userId) => {\n  const balance = balances[userId] || 0;\n  const roundedBalance = toFixed(balance);\n\n  return {\n    totalOwed: getTotalOwed(balances, userId),\n    totalOwing: getTotalOwing(balances, userId),\n    netBalance: roundedBalance,\n    isSettled: Math.abs(roundedBalance) < 0.01,\n  };\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}